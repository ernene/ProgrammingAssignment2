## The following two functions implements caching mechanism for the
## inverse of a matrix. 
## The first fuction 'makeCacheMatrix' returns a list of functions 
## as a wrapper of the original matrix that are setters and getters
## for the matrix a its inverse.
## The second function 'cacheSolve' inits and stores it with $setinverse() so
## subsequent calls to $getinverse or cacheSolve() will return 
## the stored one while not other matrix is set.

## This functions expects a parameter 'x' of type matrix 
## and returns a list with 4 fuctions that are setters and getters 
## of the matrix and its inverse.
## When original matrix (x) is init or set then the inverse is set to NULL
makeCacheMatrix <- function(x = matrix()) {
    xInverse <- NULL
    set <- function(y) {
        x <<- y
        xInverse <<- NULL
    }
    get <- function() x
    setinverse <- function(inv) xInverse <<- inv
    getinverse <- function() xInverse
    list(set = set, get = get,
         setinverse = setinverse,
         getinverse = getinverse)
}


## This fuction expects the list generated by makeCacheMatrix fuction
## and returns the inverse of the matrix.
## if inverse value is NULL then this fuction will compute it (lazy-init) 
## and store it to avoid to compute it again (cache)
cacheSolve <- function(x, ...) {
    inv <- x$getinverse()
    if(!is.null(inv)) {
        message("getting cached data")
        return(inv)
    }
    data <- x$get()
    inv <- solve(data, ...)
    x$setinverse(inv)
    inv
}
